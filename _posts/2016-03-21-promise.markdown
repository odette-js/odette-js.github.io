---
layout: post
title:  "Promise"
date:   2016-03-20 12:35:34 -0500
categories: API
author: michael mclaughlin
permalink: /api/v0/promise
---

<p>Promises are a great way to steer clear of heavily nested javascript structures that rely on passing in callbacks, by flattening the structural logic into a singular, definable, and maliable resolution tree. Most promises today are not well thought out, and even when they are, they can be highly limiting and extremely dumb. Odette's promises are backed by an extendable resolution tree that can be used to resolve to multiple "states" at a time, and create a logic pathway for your code.</p>
<p>Because of a promises usefulness, it has actually been included on the utilities object _ as well as the factories object for your extensability needs. All promises can be created in the following manner:</p>
<pre class="code code-section"><code class="language-javascript">var promise = _.Promise();</code></pre>
<p>An optional array, collection of functions, or singular function can also be passed as the first argument to be attached to the success state.</p>
<ul class="list navigation-links">
    <li class="left clear-left"><a href="#addHandler">addHandler</a></li>
    <li class="left clear-left"><a href="#allStates">allStates</a></li>
    <li class="left clear-left"><a href="#auxiliaryStates">auxiliaryStates</a></li>
    <li class="left clear-left"><a href="#baseStates">baseStates</a></li>
    <li class="left clear-left"><a href="#childEvents">childEvents</a></li>
    <li class="left clear-left"><a href="#defaults">defaults</a></li>
    <li class="left clear-left"><a href="#events">events</a></li>
    <li class="left clear-left"><a href="#execute">execute</a></li>
    <li class="left clear-left"><a href="#handle">handle</a></li>
    <li class="left clear-left"><a href="#isChildType">isChildType</a></li>
    <li class="left clear-left"><a href="#pending">pending</a></li>
    <li class="left clear-left"><a href="#reject">reject</a></li>
    <li class="left clear-left"><a href="#resolve">resolve</a></li>
    <li class="left clear-left"><a href="#resolveAs">resolveAs</a></li>
    <li class="left clear-left"><a href="#stashHandler">stashHandler</a></li>
    <li class="left clear-left"><a href="#when">when</a></li>
</ul>
<h5 id="addHandler" class="title-headline">#addHandler</h5>
<p>The add handler method is a convenience function that makes the meat of the promise object slightly easier to grasp. The real value offering of an odette promise is that it is extensible and custom resolution states can be fulfilled. This is generally done using the <a href="#handle">handle</a> function, outlined below. However, if you would like to create a convenience function then you can use the addHandler method to directly add a method and tie it to a resolution state of the same name.</p>
<div class="card">
    <div class="card-content code-step">
        <p>Below is an example of how to use the addHandler method.</p>
        <pre class="code code-section"><code class="language-javascript">var promise = _.Promise();
_.isFunction(promise.circle); // false
promise.handle('circle', function () {
    // do something
});
promise.addHandler('circle');
_.isFunction(promise.circle); // true
promise.circle(function () {
    // do another thing
});</code></pre>
    </div>
</div>
<h5 id="allStates" class="title-headline">#allStates</h5>
<div class="card">
    <div class="card-content code-step">
        <p>It is useful when creating a resolution tree to have all of the possible state resolutions available at any given time. Below is the base state resolution.</p>
        <pre class="code code-section"><code class="language-javascript">promise.allStates();
// {
//     success: 'always',
//     failure: 'always',
//     error: 'always',
//     always: true
// }</code></pre>
        <p>As you can see from the tree above, the success, failure, and error handlers all resolve to always, which terminates the tree with a non string value.</p>
    </div>
</div>
<h5 id="auxiliaryStates" class="title-headline">#auxiliaryStates</h5>
<p>In order to add more states than the base 4, odette's promise implementation allows you to extend the state tree by overwriting the auxiliaryStates method.</p>
<div class="card">
    <div class="card-content code-step">
        <p>Below is an example of a different type of tree that is also used in odette. This particular tree is used in the Ajax prototype for resolving against specific http codes when ajax calls finish.</p>
        <pre class="code code-section"><code class="language-javascript">{
    auxiliaryStates: function () {
        return {
            'status:200': 'success',
            'status:202': 'success',
            'status:205': 'success',
            'status:302': 'success',
            'status:304': 'success',
            'status:400': 'failure',
            'status:401': 'failure',
            'status:403': 'failure',
            'status:404': 'failure',
            'status:405': 'failure',
            'status:406': 'failure',
            'status:500': 'error',
            'status:502': 'error',
            'status:505': 'error',
            'status:511': 'error',
            timeout: 'failure',
            abort: 'failure'
        };
    },
}</code></pre>
        <p>These auxiliary states, compounded with the original state resolution types, give a full tree that can be followed until it resolves to always. For example, a request with a status of 200 would follow the following resolution tree: <code class="inline-code">status:200 > success > always</code>, whereas a request with a status of 400 would follow this resolution tree: <code class="inline-code">status:400 > failure > always</code></p>
    </div>
</div>
<h5 id="baseStates" class="title-headline">#baseStates</h5>
<div class="card">
    <div class="card-content code-step">
        <p>An example of the base state resolution is shown below. These states can be overwritten, but you should rarely ever need to, since there are other methods available for more extensibility.</p>
        <pre class="code code-section"><code class="language-javascript">promise.baseStates();
// {
//     success: 'always',
//     failure: 'always',
//     error: 'always',
//     always: true
// }</code></pre>
    </div>
</div>
<h5 id="isChildType" class="title-headline">#isChildType</h5>
<p>An isChildType method is used to quickly check the validity of a child that is being added to a when statement. At default, a simple check is made for the success, failure, and always methods, instead of checking the instance. This method can be overwritten in cases where a more specific child check is needed for state resolution.</p>
<h5 id="handle" class="title-headline">#handle</h5>
<p>When the handle method is called, with a string as the first, and a function as the second argument, the function will first be stashed in a queue against that state, then the promise will check to see if it is resolved, and if it is, then it will empty it's resolved state's queue.</p>
<div class="card">
    <div class="card-content code-step">
        <p>Here are a few examples outlining the behavior of calling the execute function both before and after the state has been resolved. In the following example you will notice that first the handle method is called, and then an addHandler method, and then another method, in this case, circle, which is the same as the string that was passed into the addHandler method. Note that the handle method is called before the addHandler method.</p>
        <pre class="code code-section"><code class="language-javascript">var promise = _.Promise();
promise.handle('circle', function () {
    console.log('first-circle');
});
promise.addHandler('circle');
promise.circle(function () {
    console.log('second-circle');
});
promise.resolve(); // logs 'first-circle' and 'second-circle'
promise.handle('circle', function () {
    console.log('third-circle');
}); // logs 'third-circle'
promise.circle(function () {
    console.log('fourth-circle');
}); // logs 'fourth-circle'</code></pre>
    </div>
</div>